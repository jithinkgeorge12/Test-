import * as XLSX from 'xlsx';
import { saveAs } from 'file-saver';

const Download = {
  generateExcel: (rawData, fundGroup) => {
    const sortedFundGroup = sortFundGroup(fundGroup); // Sort fundGroup alphabetically

    const dataForDownload = prepareDataForDownload(rawData, sortedFundGroup);

    if (dataForDownload.length > 0) {
      downloadExcel(dataForDownload);
    } else {
      console.error('No data found for download.');
    }
  }
};

const sortFundGroup = (fundGroup) => {
  return fundGroup.sort((a, b) => a.localeCompare(b));
};

const prepareDataForDownload = (rawData, fundGroup) => {
  let data = [];

  fundGroup.forEach((code) => {
    rawData.forEach((item, index) => {
      const date = new Date(item.dates);

      if (!isNaN(date.getTime())) {
        const formattedDate = `${('0' + date.getDate()).slice(-2)}${('0' + (date.getMonth() + 1)).slice(-2)}${String(date.getFullYear()).slice(-2)}`;

        const ref = `a${(data.length + 1).toString().padStart(8, '0')}`;

        const row = {
          ref,
          code,
          date: formattedDate,
          valuation: 0,
        };

        data.push(row);
      } else {
        console.warn(`Invalid date format found for item:`, item);
      }
    });
  });

  return data;
};

const downloadExcel = (data) => {
  const wb = generateWorkbook(data);
  const wbout = writeWorkbook(wb);

  saveAs(wbout, 'D24.xls'); // Using FileSaver.js for saving the file
};

const generateWorkbook = (data) => {
  const ws = XLSX.utils.json_to_sheet(data);

  // Set column widths based on content length + additional buffer
  const colWidths = [
    { wch: 12 }, // ref column width (8 characters + 4 for buffer)
    { wch: 6 },  // code column width
    { wch: 8 },  // date column width
    { wch: 10 }, // valuation column width
  ];

  ws['!cols'] = colWidths;

  // Apply header row style (bold, Calibri, size 11)
  applyHeaderStyle(ws, 'A1:D1');

  // Apply body cell style (Calibri, size 11)
  applyBodyStyle(ws, 'A2:D' + (data.length + 1));

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
  return wb;
};

const writeWorkbook = (wb) => {
  return XLSX.write(wb, { bookType: 'xls', type: 'binary' });
};

const applyHeaderStyle = (ws, range) => {
  const rangeArray = XLSX.utils.decode_range(range);
  for (let C = rangeArray.s.c; C <= rangeArray.e.c; ++C) {
    const cellAddress = XLSX.utils.encode_cell({ r: rangeArray.s.r, c: C });
    const cell = ws[cellAddress];
    if (!cell || !cell.s) cell.s = {};
    Object.assign(cell.s, {
      font: { bold: true, sz: 11, name: 'Calibri' },
      alignment: { horizontal: 'center', vertical: 'center' }
    });
  }
};

const applyBodyStyle = (ws, range) => {
  const rangeArray = XLSX.utils.decode_range(range);
  for (let R = rangeArray.s.r; R <= rangeArray.e.r; ++R) {
    for (let C = rangeArray.s.c; C <= rangeArray.e.c; ++C) {
      const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
      const cell = ws[cellAddress];
      if (!cell || !cell.s) cell.s = {};
      Object.assign(cell.s, {
        font: { sz: 11, name: 'Calibri' }
      });
    }
  }
};

export default Download;

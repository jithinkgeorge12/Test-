import * as XLSX from 'xlsx';

const Download = {
  generateExcel: (rawData, fundGroup) => {
    const sortedFundGroup = sortFundGroup(fundGroup); // Sort fundGroup alphabetically

    const dataForDownload = prepareDataForDownload(rawData, sortedFundGroup);

    if (dataForDownload.length > 0) {
      downloadExcel(dataForDownload);
    } else {
      console.error('No data found for download.');
    }
  }
};

const sortFundGroup = (fundGroup) => {
  return fundGroup.sort((a, b) => a.localeCompare(b));
};

const prepareDataForDownload = (rawData, fundGroup) => {
  let data = [];

  fundGroup.forEach((code) => {
    rawData.forEach((item, index) => {
      const date = new Date(item.dates);

      if (!isNaN(date.getTime())) {
        const formattedDate = `${('0' + date.getDate()).slice(-2)}${('0' + (date.getMonth() + 1)).slice(-2)}${String(date.getFullYear()).slice(-2)}`;

        const ref = `a${(data.length + 1).toString().padStart(8, '0')}`;

        const row = {
          ref,
          code,
          date: formattedDate,
          valuation: 0,
        };

        data.push(row);
      } else {
        console.warn(`Invalid date format found for item:`, item);
      }
    });
  });

  return data;
};

const downloadExcel = (data) => {
  const wb = generateWorkbook(data);
  const wbout = writeWorkbook(wb);

  triggerDownload(wbout);
};

const generateWorkbook = (data) => {
  const ws = XLSX.utils.json_to_sheet(data);

  // Set column widths based on content length + additional buffer
  const colWidths = [
    { wch: 12 }, // ref column width (8 characters + 3)
    { wch: 6 },  // code column width
    { wch: 8 },  // date column width
    { wch: 10 }, // valuation column width
  ];

  ws['!cols'] = colWidths;

  // Set style for each cell in the worksheet to Calibri, size 11
  const bodyStyle = {
    font: { sz: 11, name: 'Calibri' },
  };

  // Apply body style to all cells in the worksheet
  const range = XLSX.utils.decode_range(ws['!ref']);
  for (let R = range.s.r; R <= range.e.r; ++R) {
    for (let C = range.s.c; C <= range.e.c; ++C) {
      const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
      if (!ws[cellAddress]) continue;
      ws[cellAddress].s = bodyStyle;
    }
  }

  // Set header row styles
  const headerStyle = {
    font: { bold: true, sz: 11, name: 'Calibri' },
  };

  const headerRange = { s: { r: 0, c: 0 }, e: { r: 0, c: ws['!cols'].length - 1 } };
  for (let C = headerRange.s.c; C <= headerRange.e.c; ++C) {
    const cellAddress = XLSX.utils.encode_cell({ r: headerRange.s.r, c: C });
    if (!ws[cellAddress]) continue;
    ws[cellAddress].s = headerStyle;
  }

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
  return wb;
};

const writeWorkbook = (wb) => {
  return XLSX.write(wb, { bookType: 'xls', type: 'array' });
};

const triggerDownload = (wbout) => {
  const blob = new Blob([wbout], { type: 'application/vnd.ms-excel' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'D24.xls'; // Set the filename here

  document.body.appendChild(a);
  a.click();

  setTimeout(() => {
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
  }, 0);
};

export default Download;
